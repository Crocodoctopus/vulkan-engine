#version 450
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct VkDrawIndexedIndirectCommand {
    uint index_count;
    uint instance_count;
    uint first_index;
    int vertex_offset;
    uint first_instance;
};

struct MeshletData {
    // Culling.
    vec3 center;
    float radius;
    vec3 cone_apex;
    float pad0;
    vec3 cone_axis;
    float cone_cutoff;

    // Draw cmd.
    uint object_id;
    uint index_count;
    uint first_index;    
};

struct Instance {
    uint object_id;   
};

struct Object {
    mat4 model;
    uint tex_id;
};

//////

layout (buffer_reference, std430) readonly buffer ObjectBuffer {
    Object data[];  
};

layout (buffer_reference, std430) coherent buffer DrawCountBuffer {
    uint counter;
};

layout (buffer_reference, std430) readonly buffer MeshletBuffer {
    MeshletData data[];
};

layout (buffer_reference, std430) writeonly buffer DrawCmdBuffer {
    VkDrawIndexedIndirectCommand data[];  
};

layout (buffer_reference, std430) writeonly buffer InstanceBuffer {
    Instance data[];  
};

layout (std430, set = 0, binding = 0) uniform Global {
    vec3 camera_position;
    uint instances;

    // Frustum.
    vec4 frustum_left;
    vec4 frustum_right;
    vec4 frustum_top;
    vec4 frustum_bottom;
    vec4 frustum_near;
    vec4 frustum_far;

    // Buffers.
    DrawCountBuffer draw_count_buffer;
    MeshletBuffer meshlet_buffer;
    DrawCmdBuffer draw_cmd_buffer;
    InstanceBuffer instance_buffer;
    ObjectBuffer object_buffer;
};

// Distance to plane
// return dot(vec4(vPoint, 1.0), vPlane);

void main() {
    // 
    if (gl_GlobalInvocationID.x >= instances) return;

    //
    MeshletData meshlet = meshlet_buffer.data[gl_GlobalInvocationID.x];
    Object object = object_buffer.data[meshlet.object_id];

    // Frustum cull.
    vec4 center = object.model * vec4(meshlet.center, 1.0);
    float d0 = min(dot(center, frustum_left), dot(center, frustum_right));
    float d1 = min(dot(center, frustum_bottom), dot(center, frustum_top));
    float d2 = min(dot(center, frustum_near), dot(center, frustum_far));
    if (min(min(d0, d1), d2) + meshlet.radius <= 0) return;
        
    // Backface cull.
	vec3 cone_apex = (object.model * vec4(
		meshlet.cone_apex, 1.0)).xyz;
	
	vec3 cone_axis = (object.model * vec4(
		meshlet.cone_axis, 0.0)).xyz;

	float cone_cutoff = meshlet.cone_cutoff;
	
    //if (dot(normalize(cone_apex - camera_position), cone_axis) < cone_cutoff) return;
//	bool bConeCulled = dot(normalize(coneApex - cameraPosition), center) >= coneCutoff;
///   `dot(normalize(cone_apex - camera_position), cone_axis) >= cone_cutoff`
		

    
    //vec4 axis = object.model * vec4(meshlet.cone_axis, 0.0);
    //vec4 apex = object.model * vec4(meshlet.cone_apex, 1.0);
    //if (gl_GlobalInvocationID.x % 2 == 0) return;

    // Append draw command.
    const uint i = atomicAdd(draw_count_buffer.counter, 1);
    draw_cmd_buffer.data[i].index_count = meshlet.index_count;
    draw_cmd_buffer.data[i].first_index = meshlet.first_index;
    draw_cmd_buffer.data[i].instance_count = 1;
    draw_cmd_buffer.data[i].vertex_offset = 0;
    draw_cmd_buffer.data[i].first_instance = 0;
    instance_buffer.data[i].object_id = meshlet.object_id;
}
